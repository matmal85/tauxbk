<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Taux</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; }
    .box { max-width: 1100px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border-bottom: 1px solid #ddd; padding: 10px; text-align: left; vertical-align: top; }
    input, select { padding: 8px; font-size: 14px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .muted { color: #666; font-size: 13px; margin-top: 6px; }
    .pill { display:inline-block; padding:3px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    .search { min-width: 260px; }
  </style>
</head>
<body>
  <div class="box">
    <h1>Taux</h1>

    <div class="row">
      <label for="datePick">Date</label>
      <input id="datePick" type="date" />
      <input id="search" class="search" placeholder="Filtrer (ex: euribor, ester, swap...)" />
      <span class="pill" id="badge">—</span>
    </div>

    <div class="muted" id="status"></div>

    <h2>Derniers cours</h2>
    <table id="latestTable">
      <thead><tr><th>Taux</th><th>Dernière date</th><th>Dernier cours</th></tr></thead>
      <tbody></tbody>
    </table>

    <h2>Cours à la date sélectionnée</h2>
    <table id="selectedTable">
      <thead><tr><th>Taux</th><th>Date</th><th>Cours</th></tr></thead>
      <tbody></tbody>
    </table>

    <p class="muted">
      Ajout d’un taux = ajouter une ligne dans <code>rates.json</code>.
      Mensuel (YYYY-MM) ou quotidien (YYYY-MM-DD) : géré automatiquement.
    </p>
  </div>

<script>
  const badgeEl = document.getElementById("badge");
  const statusEl = document.getElementById("status");
  const datePick = document.getElementById("datePick");
  const searchEl = document.getElementById("search");

  function setStatus(msg) { statusEl.textContent = msg; }
  function setBadge(text) { badgeEl.textContent = text; }

  // Affichage DD/MM/YYYY (accepte YYYY-MM ou YYYY-MM-DD)
  function formatDate(iso) {
    if (!iso) return "—";
    const p = iso.split("-");
    if (p.length === 2) { // YYYY-MM
      const [y, m] = p;
      return `01/${m}/${y}`;
    }
    if (p.length === 3) { // YYYY-MM-DD
      const [y, m, d] = p;
      return `${d}/${m}/${y}`;
    }
    return iso;
  }

  // Arrondi 6 décimales
  function formatNumber(val) {
    if (val == null || val === "") return "—";
    const n = Number(val);
    if (Number.isNaN(n)) return "—";
    return n.toFixed(6);
  }

  // Parse CSV ECB : cherche TIME_PERIOD et OBS_VALUE
  function parseCsv(text) {
    const lines = text.trim().split(/\r?\n/);
    const headers = lines[0].split(",");
    const idxTime = headers.indexOf("TIME_PERIOD");
    const idxVal  = headers.indexOf("OBS_VALUE");
    if (idxTime === -1 || idxVal === -1) throw new Error("Colonnes TIME_PERIOD / OBS_VALUE introuvables");

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",");
      const time = cols[idxTime];
      const valStr = cols[idxVal];
      const val = (valStr === "" || valStr == null) ? null : Number(valStr);
      if (time) rows.push({ time, val });
    }
    rows.sort((a,b) => a.time.localeCompare(b.time));
    const latest = rows[rows.length - 1];
    const map = new Map(rows.map(r => [r.time, r.val]));
    return { latest, map };
  }

  async function loadRatesList() {
    const res = await fetch("rates.json", { cache: "no-store" });
    if (!res.ok) throw new Error("Impossible de charger rates.json (HTTP " + res.status + ")");
    return await res.json();
  }

  async function loadOneRate(rate) {
    const res = await fetch(rate.url, { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const { latest, map } = parseCsv(await res.text());
    return { ...rate, latest, map };
  }

  function renderLatest(list, filterText) {
    const tbody = document.querySelector("#latestTable tbody");
    tbody.innerHTML = "";
    list
      .filter(r => (r.label + " " + r.id).toLowerCase().includes(filterText))
      .forEach(r => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${r.label}</td>
          <td>${formatDate(r.latest?.time)}</td>
          <td>${formatNumber(r.latest?.val)}</td>
        `;
        tbody.appendChild(tr);
      });
  }

  // Sélection : on essaie d’abord quotidien (YYYY-MM-DD), sinon mensuel (YYYY-MM)
  function renderSelected(list, isoDate, filterText) {
    const tbody = document.querySelector("#selectedTable tbody");
    tbody.innerHTML = "";

    const dayKey = isoDate;            // YYYY-MM-DD
    const monthKey = isoDate.slice(0,7); // YYYY-MM

    list
      .filter(r => (r.label + " " + r.id).toLowerCase().includes(filterText))
      .forEach(r => {
        let val = r.map.get(dayKey);
        let shownKey = dayKey;

        if (val == null) {
          val = r.map.get(monthKey);
          shownKey = monthKey;
        }

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${r.label}</td>
          <td>${formatDate(shownKey)}</td>
          <td>${formatNumber(val)}</td>
        `;
        tbody.appendChild(tr);
      });
  }

  async function main() {
    setBadge("Chargement…");
    setStatus("Lecture de rates.json…");

    const rates = await loadRatesList();

    setStatus("Chargement des taux (" + rates.length + ")…");
    const loaded = [];
    for (const r of rates) {
      loaded.push(await loadOneRate(r));
    }

    setBadge("OK");
    setStatus("");

    // Date par défaut = aujourd’hui (si pas dispo, tu peux changer)
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth()+1).padStart(2,"0");
    const dd = String(today.getDate()).padStart(2,"0");
    datePick.value = `${yyyy}-${mm}-${dd}`;

    const refresh = () => {
      const filterText = (searchEl.value || "").trim().toLowerCase();
      renderLatest(loaded, filterText);
      if (datePick.value) renderSelected(loaded, datePick.value, filterText);
    };

    datePick.addEventListener("change", refresh);
    searchEl.addEventListener("input", refresh);
    refresh();
  }

  main().catch(e => {
    setBadge("Erreur");
    setStatus("Erreur: " + (e.message || e));
  });
</script>
</body>
</html>
